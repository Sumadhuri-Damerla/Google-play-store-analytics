---
title: 
   <center><h2> Google Play Store Analytics with R </h2></center>
subtitle: 
   <center><h3> Data analytics project work </h3> </center>
author: 
  <center><h5> Group3- Sumadhuri Damerla,Shaoor Jan,Ashjan Khan </h5> </center>
output: 
   html_document: 
    theme: cosmo
    highlight: monochrome
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    fig_caption: true
    number_sections: true
    df_print: paged
    css: styles.css
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=8, fig.path='Figures/',
                      echo=FALSE, warning=FALSE, message=FALSE)
```

# Introduction  
The **google play store** [dataset](https://www.kaggle.com/lava18/google-play-store-apps) offers insights into different apps, their ratings, user-reviews, installs and many other variables. In this report,we explore the dataset to find relations between columns

## Data source
The data source used for this analysis is the *2018 google play store*(https://www.kaggle.com/lava18/google-play-store-apps) collected from Kaggle.

## R packages
Below is a list of R packages used for this analysis.Package tidyverse is a collection of R packages for data science, including dplyr and tidyr for data processing and ggplot2 for graphics. Package gridExtra is for arranging multiple
grid-based plots on a page and kableExtra works together with kable() from knitr to build complex HTML
or LaTeX tables.

```{r loading_libraries,echo = TRUE}

library(tidyverse)
library(dplyr)
library(stringr)
require(ggExtra) # For marginal graphs
require(GGally) #for correlation plot
theme_set(theme_light())

```

## Creating a custom color pallete

Research has shown that specific concepts and phenomenon are associated with specific colors e.g money is most often associated with green color, oceans with blue and love with red. When colors are associated with the concepts that evoke them, this is called “semantically resonant color choices.” This concept is remarkably important for data visualization, and its effective communication. For this purpose, we created a custom color pallet, containing colors that are associated with the concepts of our dataset. This also help us be consistent with our choices of colors. 
Keeping in view accessibility, we have used colors that are color blind friendly. 
```{r custom_color_pallete}
# reference: https://drsimonj.svbtle.com/creating-corporate-colour-palettes-for-ggplot2

custom_colors <- c(
  `red`             = "#d11141",
  `blueish green`   = "#009E73",
  `blue`            = "#0072B2",
  `sky blue`        = "#56B4E9",
  `orange`          = "#E69F00",
  `vermillion`      = "#D55E00",
  `yellow`          = "#009E73",
  `grey`            = "#999999",
  `reddish purple`  = "#CC79A7"
)

custom_cols <- function(...) {
  cols <- c(...)
  
  if (is.null(cols))
    return (custom_colors)
  
  custom_colors[cols]
}

custom_palettes <- list(
  `main`  = custom_cols("blue", "green", "yellow"),
  
  `cool`  = custom_cols("blue", "green"),
  
  `hot`   = custom_cols("yellow", "orange", "red"),
  
  `mixed` = custom_cols("blue", "green", "yellow", "orange", "red"),
  
  `grey`  = custom_cols("light grey", "dark grey")
)

custom_pal <- function(palette = "main", reverse = FALSE, ...) {
  pal <- custom_palettes[[palette]]
  
  if (reverse) pal <- rev(pal)
  
  colorRampPalette(pal, ...)
}

scale_color <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)
  
  if (discrete) {
    discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_color_gradientn(colours = pal(256), ...)
  }
}

scale_fill <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)
  
  if (discrete) {
    discrete_scale("fill", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_fill_gradientn(colours = pal(256), ...)
  }
}

```


## Loading Data
```{r loading_data}

play_store <- read_csv("data/googleplaystore.csv")

```
The loaded play store data contains 10841 rows.

# Analysis
## View the dataset {.tabset .tabset-fade .tabset-pills}

### Sneak peak at the data
```{r}

head(play_store)

```

### No. of rows
```{r}

dim(play_store)

```
The dataset contains `r dim(play_store) [1] ` rows and `r dim(play_store) [2] ` columns. By looking deeper into the dataset, it become clear that there are duplicate observations. The number of unique values in the column are `r length(unique(play_store$app)) `. Thus, we need to remove `r (dim(play_store) [1] - length(unique(play_store$app))) ` duplicate values.


### Summary of data
```{r}

summary(play_store)

```

1. Summary shows that there are `r sum(is.na(play_store$rating))` missing values in rating column and `r sum(is.na(play_store$reviews))` missing value in reviews column. 
2. Rating can only be NaN or null if the number of reviews are 0. Observations with NaN rating and number of reviews greater than zero does not represent correct data. As the number of these observations is less as compared to the whole dataset, we decided to remove them. 

### Structure of data
```{r}

str(play_store)

```
As can be seen from the table, the data contains missing values, duplicates and many inconsistencies. --Add related text here

## Exploring and Tidying Data
As seen in above section, column names in the dataset are not in accordance with the good practices and conventions of R, and were replaced with names that are in accordance with the naming conventions in R. 
```{r tidydata}

# changing column names to remove spaces and other special characters and to maintain consistency
colnames(play_store) <- c("app", "category", "rating", "reviews", "size_mb", "installs", "types", "price", "content_rating", "genres", "last_update", "current_ver", "android_ver")

```


### App column:

```{r app_col}

length(unique(play_store$app)) #number of unique apps in dataset

```

The number of rows in the dataset equals 10841 but the application names column has only 9660 unique values, ie there are applications with the same name. The following graph prompts us to ask the following questions:

 1.Why are there names of apps that are repeated more than once? 
 
 2.Is it the same application or different applications with the same name? After inspecting applications with the same names, it was found that these applications had almost the same characteristics, for the majority of them there was a difference in the number of reviews while others had differences in the number of reviews. the size, category and date of last update. This observation has pushed us to deepen our research to see if it is possible to have multiple applications with the same display name, actually this is possible provided you have different package names. It is later considered that these duplicate applications are due to a data collection error for two reasons:  
 
 3.Duplicate applications are recognized applications like Google Drive, Google Photos and Duolingo having a large number of installation (the same number) and the same evaluation rate. These application names are registered trademarks, so launching apps with these same names can lead to legal problems if there has been a decision to defend this trademark.  
 
 4.The dataset is published on Kaggle in 5 different versions, with a duration of one month between the first and the last version. It could therefore evolve during this period.  

#### Removing the duplicate values
```{r Removing duplicate values}

#  Observations: Dataset include two different observations for the same app, with different reviews (number of reviews), we kept the lesser number, so not to create overly optimistic results
# another option is to take mean of the duplicate values and use it instead
arranged_data_set <- play_store %>% 
  arrange(app, desc(reviews))
dpl_value <- which(!duplicated(arranged_data_set$app))  
new_play_store <- arranged_data_set[dpl_value,]
clean_play_store <- arranged_data_set[dpl_value,]

```


### Category:
Number of unique apps:
```{r category_col}

# Total number of categories
length(unique(play_store$category))

```

#### Category plot
```{r category_plot1}
#Bar plot
 play_store %>%
    ggplot(aes(x = reorder(category, category, function(category) -length(category)) , fill = custom_cols("orange"))) +
    geom_bar(width = 0.5) +
    labs(title = "Bar Chart",
         subtitle = "Number of Apps in each Categories",
         y = "Count",
         x = "Category",
         caption = "Source: google play store dataset") +
    theme(legend.position = "None",
          axis.text.x = element_text(angle = 90)
          )
```

+ We can observe that the family category has the most number of apps followed by game and tool categories.  
+ We have one observation having a category named 1.9 with a single application. Examining this application, we notice that it is an error due to a left shift.  


Removing data for wrong entered app:"Life Made WI-Fi Touchscreen Photo Frame" 
```{r remove_wrongdata}

#### Removing wrong app-data ####
# Data for app "Life Made WI-Fi Touchscreen Photo Frame" removed (wrong rating, reviews, size e.t.c)
  clean_play_store <- clean_play_store[clean_play_store$app != "Life Made WI-Fi Touchscreen Photo Frame", ]

```

#### Percentage category plot after cleaning the column
```{r category_plot2}

  clean_play_store %>% 
    group_by(category)  %>% 
    summarise(count_of_apps = length(app)) %>% 
    arrange(-count_of_apps) %>% 
    mutate(perc_category = (count_of_apps / sum(count_of_apps) * 100 )) %>%
    ggplot(aes(x = reorder(category, -perc_category) , y = perc_category, fill = custom_cols("orange"))) +
    geom_bar(width = 0.5, stat = "identity") +
    geom_text(size = 2,position=position_dodge(width = 1),vjust = -0.3,aes(label = round(perc_category,2))) +
    labs(title = "Bar Chart",
         subtitle = "Percentage Apps in each Categories",
         y = "Percentage",
         x = "Category",
         caption = "Source: google play store dataset") +
    theme(legend.position = "None",
          axis.text.x = element_text(angle = 90)
          )

```

### Rating:

Table included missing values as shown below  
```{r detect_missing_data}

# Detect null cols and null rate
table(is.na(play_store))

colSums(is.na(play_store))

```
Missing rates are very low. We choose to delete them


Removing observations with NaN rating which have reviews  
```{r remove_missing_data}

#### removing observations with reviews but NaN rating ####
 diff <- count(subset(new_play_store)) - count(subset(clean_play_store, !(is.na(clean_play_store$rating) & !clean_play_store$reviews == "0" )))

 clean_play_store <- subset(clean_play_store, !(is.na(clean_play_store$rating) & !clean_play_store$reviews == "0" ))

```


#### Rating plot
```{r rating_plot}

#Density plot
clean_play_store %>%
  ggplot(aes(x = rating)) +
  geom_density(aes(fill = factor(types)), alpha = 0.5) +
  labs(title = "Density plot",
       subtitle = "App Rating grouped by types",
       y = "Values",
       x = "Rating",
       caption = "Source: google play store dataset",
       fill = "#Types") +
   theme(axis.text.x = element_text(vjust=0.5))

```

We can observe that there are very few apps with low ratings and most ratings are between 3-5

### Review : 
We modify datatype of "reviews" column to numeric  
```{r review_col}

#### converting reviews to numeric ####
  clean_play_store$reviews <- as.numeric(clean_play_store$reviews)

```  


#### Review distribution plot
```{r reviews_plot}

clean_play_store %>%
  ggplot(aes(x = reviews))+
  geom_histogram(binwidth = 0.1,fill = custom_cols("reddish purple"))+
  scale_x_log10(labels = scales::comma) +
  geom_vline(xintercept = median(clean_play_store$reviews), color = custom_cols("sky blue")) +
  labs(title = "Histogram plot",
       subtitle = "Distribution of Reviews",
       y = "Count",
       x = "Review",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
        legend.position = "None") 
 
```

```{r summary}

#summary
summary(clean_play_store$reviews)

```

The number of reviews follows a left skewed distribution. About half the apps 
have more than 2747 reviews.(red line is the median)
 
### Size:

Convert all the app sizes to mb and modify it's datatype to numeric 
```{r size_col}

#### Convert all app sizes to MB ####
  # changing all app sizes to MB
  selectedRows <- grep("k", clean_play_store$size_mb)
  clean_play_store$size_mb <- gsub('k', '', clean_play_store$size_mb)
  clean_play_store$size_mb <- gsub('M', '', clean_play_store$size_mb)
  clean_play_store$size_mb[selectedRows] <- as.numeric(clean_play_store$size_mb[selectedRows])  / 1024
  
  # convert into numeric 
  clean_play_store$size_mb <- as.numeric(clean_play_store$size_mb)

```

```{r size_plot}

clean_play_store %>%
  ggplot(aes(x = size_mb))+
  geom_density(binwidth = 0.5,fill = custom_cols("vermillion"))+
  labs(title = "Density plot",
       subtitle = "Size in MB",
       y = "Density",
       x = "Size (MB)",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
         legend.position = "None")

```

### Installs:

Remove unwanted characters in "installs" column and modufy it's datatype to numeric  
```{r installs_col}

#### install column: remove "+", "," and convert into numeric ####
  # removing "+", ","
  clean_play_store$installs <- gsub('[[:punct:]]', '', clean_play_store$installs)
  
  # convert into numeric 
  clean_play_store$installs <- as.numeric(clean_play_store$installs)

```

```{r installs_plot}

clean_play_store %>%
  ggplot(aes(x = installs))+
  geom_density(fill = custom_cols("sky blue"))+
  labs(title = "Bar Chart",
       subtitle = "Distribution of installs",
       y = "Count",
       x = "Installs",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
         legend.position = "None")

```

### Price:

We already know that paid apps only account for 7.46% of our dataset. Therefore, we will only look at the prices of paid applications. To do this, we will eliminate the dollar symbol and convert prices into numerical values.
```{r price_col}

####  price column: remove '$' and convert into numeric ####
  # removing "$"
  clean_play_store$price <- gsub( "\\$", '', clean_play_store$price)
  
  # convert into numeric 
  clean_play_store$price <- as.numeric(clean_play_store$price)

```

#### Price plot
```{r price_plot}

clean_play_store %>%
  ggplot(aes(x = price)) +
  geom_histogram(fill = custom_cols("blueish green"), binwidth = 5) +
  scale_y_log10() +
  labs(title = "Histogram plot",
       subtitle = "Distribution of price",
       y = "Count",
       x = "Price",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5))

```

Most of the apps are affordable and we can observe one outlier at 400 dollar range.

### Content rating:

Seperate content rating column  
```{r content_col}

#### seperate content rating column ####
  clean_play_store$content_rating <- gsub( '\\+', '', clean_play_store$content_rating )
  
  clean_play_store <-  clean_play_store %>% 
    separate(content_rating, c("content_rating", "min_age"), convert = TRUE, sep = "\\s+(?=\\S*$)")

```

### Last update:  

Modify the datatype of "last_update" column to date 
```{r last_update_col}

#### Convert last_update column into date ####
   clean_play_store$last_update <- as.Date(clean_play_store$last_update, format = "%d-%b-%y")
  
```

### Types:
```{r types_col}

summary(play_store$types)

## There is one row with NaN value, let's check this row
play_store[play_store$types == 'NaN',]

```
As shown, price of this app is equal to 0 which means the App is Free
change the value of Type to Free

```{r types_tidy}

#### Removing NAN in type column  
   clean_play_store$types <-  gsub(NaN, 'Free', clean_play_store$types) 

```

#### Pie plot of type
```{r type_plot}

clean_play_store %>%
  ggplot(aes(x = factor(1), fill = types)) +
  geom_bar(width = 1, alpha = 0.7) +
  coord_polar(theta = "y", start = 0) +
  labs(title = "Pie Chart",
       subtitle = "Free and Paid App Distribution",
       y = "App Count",
       x = "Factor(1)",
       caption = "Source: google play store dataset",
       fill = "Types") +
  theme(axis.ticks = element_blank(),
        panel.grid  = element_blank(),
        legend.title = element_text(hjust = 0.5, face = "bold", size = 10)) +
  scale_fill(palette = "main") 

```

We can see that most of the apps are free.

### Android version:  

Splitting android_ver column into two columns: min_android_ver and max_android_ver. "up" in max_android_ver indicates the app is supported by latest versions of android.  
```{r android_ver_col}
#### current version column ####

# Indexes of strings with different patterns 
null_rows <- grep( NaN, clean_play_store$android_ver)
varies_with_dev_row <- grep("Varies with device", clean_play_store$android_ver)
with_dash <- grep("-", clean_play_store$android_ver)
and_up_obs <- grep("and", clean_play_store$android_ver)
  
# values with dash 
and_ver_with_dash_temp <- clean_play_store$android_ver[with_dash] 
and_ver_with_dash <-  sub(".*\\s", "", and_ver_with_dash_temp)

# Seperating column min_android_ver
clean_play_store <-  clean_play_store %>% 
  separate(android_ver, c("min_android_ver", "max_android_ver"), convert = TRUE, sep = "\\s")
    
# Varies with device remived
clean_play_store$min_android_ver[varies_with_dev_row] <-  NA 
clean_play_store$max_android_ver[varies_with_dev_row] <-  NA 
 
# up in max_android_ver
clean_play_store$max_android_ver[and_up_obs] <-  "up"

# NaN in max_android_ver
clean_play_store$max_android_ver[null_rows] <-  NA
clean_play_store$min_android_ver[null_rows] <-  NA
 
# "-" values in max_android_ver   
clean_play_store$max_android_ver[with_dash] <- and_ver_with_dash

 
```


#### Number of installs based on support by minimum android version
```{r android_ver,warning=FALSE,message=FALSE}

clean_play_store %>%
  ggplot(aes(x = min_android_ver, fill = types )) +
  geom_bar(width = .5, alpha = 0.7, na.rm = TRUE) +
  labs(title = "Bar Chart",
       subtitle = "Installs Based on Min. Android Version",
       x = "Min. Android Version",
       y = "Count",
       caption = "Source: google play store dataset",
       fill = "Types") +
 theme(legend.title = element_text(hjust = 0.5, face="bold", size = 10),
       axis.text.x = element_text(angle = 90)
                                )
  

```



# Further EDA
## Explore data after data cleaning and transformation {.tabset .tabset-fade .tabset-pill}
### A look at the structure of data
```{r view_clean_data}

str(clean_play_store)

``` 

### A look at the summary of clean data
```{r summary_clean_data}

summary(clean_play_store)

``` 
Rating ranges from 1 to 5 and the mean is pretty high. 

## Pair plot {.tabset .tabset-fade .tabset-pills}

### Rating vs Reviews
````{r pairplot1}

clean_play_store$Reviews <- log(clean_play_store$reviews)

clean_play_store %>%
  select(rating, Reviews) %>%
  ggpairs(
          mapping = ggplot2::aes(color = "types")) +
  labs(title = "Correlogram",
       subtitle = "Rating vs Reviews",
        caption = "Source: google play store dataset") 
```

### Rating vs Size
````{r pairplot6}

clean_play_store %>%
  select(rating, size_mb) %>%
  ggpairs(
          mapping = ggplot2::aes(color = "types")) +
  labs(title = "Correlogram",
       subtitle = "Rating vs Size (MB)",
        caption = "Source: google play store dataset") 
```

### Rating vs Installs
````{r pairplot2}

clean_play_store$Installs <- log(clean_play_store$installs)

clean_play_store %>%
  select(rating, Installs) %>%
  ggpairs(mapping = ggplot2::aes(color = "types")) +
  labs(title = "Correlogram",
       subtitle = "Rating vs Installs",
       caption = "Source: google play store dataset")

```

### Rating vs Price
````{r pairplot3}

clean_play_store$Price <- log(clean_play_store$price)

clean_play_store %>%
  select(rating, Price) %>%
  ggpairs(mapping = ggplot2::aes(color = "types")) +
  labs(title = "Correlogram",
       subtitle = "Rating vs Price",
       caption = "Source: google play store dataset")

```

### Rating vs Types  
````{r pairplot4}
clean_play_store$types <- as.factor(clean_play_store$types)

clean_play_store %>%
  select(rating, types) %>%
  ggpairs(mapping = ggplot2::aes(color = "types")) +
  labs(title = "Correlogram",
       subtitle = "Rating vs Types",
       caption = "Source: google play store dataset")

```


We can observe that there is no significant linear relationship between rating and the plotted numerical variables.

## Bivariate & Multivariate plots

To look at which app makes it to the top, we consider ratings, so we can explore correlation of different columns with ratings

### Plot of reviews vs app ratings
``` {r review_rating_plot}
ggplot(data = clean_play_store) +
  geom_point(mapping = aes(x = rating, y = reviews, col = types)) +
  scale_color(palette = "hot") +
  scale_y_continuous(trans = 'log10', labels = scales::comma) +
  labs(title = "Dot plot",
       subtitle = "Android App Ratings vs Number of Reviews",
       x = "Rating from 1 to 5 stars",
       y = "Number of Reviews",
       caption = "Source: google play store dataset",
       fill = "Types") +
 theme(legend.title = element_text(hjust = 0.5, face="bold", size = 10))

```


We can observe that the number of reviews influence the ratings. Generally, as the number of reviews increase, the rating is higher.


Let's explore other factors that might potentially influence rating

### App rating vs category
```{r rating_category_plot}

clean_play_store %>%
  ggplot(aes(x = reorder(category,rating), y = rating))+
  geom_boxplot(aes(fill = category)) +
  scale_fill(palette = "main") +
  labs(title = "Boxplot",
       subtitle = "Android App Ratings by category",
       x = "Category",
       y = "Rating",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(angle = 90),
         legend.position = "None")
```

### Number of installs {.tabset .tabset-fade .tabset-pill}

#### Number of installs per category
```{r installs_plot1}

clean_play_store%>%
  count(category, installs, types) %>%
  group_by(category, types) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = log(totalInstalls), fill = types)) +
  geom_bar(width = 0.5,stat = "identity") +
  scale_y_continuous(labels = scales::comma) +
  labs(title = "Bar Chart",
       subtitle = "Number of Installs per Category",
       x = "Category",
       y = "Number of Installs(log)",
       caption = "Source: google play store dataset") +
  scale_fill(palette = "main") +
  theme(axis.text.x = element_text(angle = 90)) 

```


#### Top 10 installed categories  
```{r top_apps_plot}

clean_play_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls), y = totalInstalls, fill = custom_cols("red"))) +
  geom_bar(width = 0.5, fill = custom_cols("blueish green"), stat = "identity") +
  labs(title = "Bar Chart",
       subtitle = "Top 10 Installed Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "None") 

```

#### Ten least installed categories
```{r least_apps_plot}


clean_play_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  tail(10) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = totalInstalls)) +
  geom_bar(width = 0.5, fill = custom_cols("vermillion"), stat = "identity") +
  labs(title = "Bar Chart",
       subtitle = "10 Least Installed Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "None") 
```


Since most of the apps are free, let's look at top 10 paid apps:  

### Top 10 paid apps 
```{r top_paid_apps_plot}

clean_play_store %>%
  filter(types == "Paid") %>%
  group_by(category) %>%
  summarize(totalInstalls = sum(installs)) %>%
  arrange(desc(totalInstalls)) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls) , y = totalInstalls)) +
  geom_bar( fill = custom_cols("blueish green"), stat = "identity", width = 0.5) +
  labs(title = "Bar Chart",
       subtitle = "Top 10 Paid Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 65, vjust = 0.5),
        legend.position = "None") 

```



### Distribution of rating for 8 categories with the largest numbers of apps 

```{r avg_rating_plot}

# Distribution of rating for 8 categories with the largest numbers of apps
clean_play_store %>% 
 filter( category == c("FAMILY", "GAME", "TOOLS","MEDICAL", " BUSINESS", "PRODUCTIVITY", "FINANCE", "COMMUNICATION", "SPORTS")) %>% 
  ggplot(aes(x = rating)) +
  geom_bar(fill = custom_cols("blueish green"), na.rm = TRUE) + 
  facet_wrap(~category,  ncol = 4, nrow = 4,  shrink = TRUE) +
  labs(title = "Facet plot",
       subtitle = "Distribution of rating for 8 categories with the highest numbers of apps",
       x = "Rating",
       y = "Count",
       caption = "Source: google play store dataset")

```

### Average rating per category 
```{r avg_rating_category_plot}

# Average rating per category
clean_play_store %>% 
  select(c("category", "rating")) %>% 
  group_by(category) %>% 
  summarise(rating = mean(rating, na.rm = TRUE)) %>% 
  ggplot(aes(x = reorder(category, - rating) , rating)) + 
  geom_col(width = 0.5, fill = custom_cols("sky blue")) +
  ggtitle("Average Rating Per Category") +
  labs(title = "Bar Chart",
       subtitle = "Average Rating Per Category",
       y = "Rating", 
       x = "Category",
      caption = "Source: google play store dataset") +
  theme(axis.text.x = element_text(angle = 90),
        legend.position = "none" ) 

```



### Size and rating  
```{r size_rating_plot}

plot <- clean_play_store %>% 
  ggplot(aes(x = size_mb, y = rating, na.rm = TRUE)) + 
  geom_point(color = custom_cols("blueish green"),na.rm = TRUE) +
  labs(title = "Marginal Plot",
       subtitle = "Size Vs Rating",
       y = "Rating", 
       x = "Size (MB)",
      caption = "Source: google play store dataset") 

 ggMarginal(plot, type = "histogram", fill = custom_cols("blueish green"), alpha = 0.6)

```

We can see that apps with the their sizes under 30 MB, constitute the majority with a good rating(4)


### Size and number of installs  
```{r size_installs_plot}

plot <- clean_play_store %>% 
  filter(!is.na(size_mb) ) %>% 
  ggplot(aes(x = size_mb, y = log(installs + 0.005), na.rm = TRUE)) + 
  geom_point(color = custom_cols("vermillion"), na.rm = TRUE) + 
  labs(title = "Marginal Plot",
       subtitle = "Size Vs Number of Installs",
       y = "No. of Installs (Log)", 
       x = "Size (MB)",
      caption = "Source: google play store dataset")
  ggMarginal(plot, type = "histogram", fill = custom_cols("vermillion"), alpha = 0.6)

```

Apps with sizes between 5MB and 30MB gets the most number of installs. 

# References

* [Dataset](https://www.kaggle.com/lava18/google-play-store-apps);
* [R markdown](https://bookdown.org/yihui/rmarkdown/html-document.html#tabbed-sections) ;
* [Stackoverflow](https://stackoverflow.com/questions/3993301/how-to-format-number-values-for-ggplot2-legend/15007117) ;
* [GGally](https://ggobi.github.io/ggally/rd.html#ggpairs);
* [Custom color pallete](https://drsimonj.svbtle.com/creating-corporate-colour-palettes-for-ggplot2);
* [Tidying data](https://medium.com/coinmonks/dealing-with-missing-data-using-r-3ae428da2d17);
* [Colors](https://hbr.org/2014/04/the-right-colors-make-data-easier-to-read);
* [TidyVerse](https://www.tidyverse.org/);
* [ggplot2](https://ggplot2.tidyverse.org/reference/);
* [Google playstore Kernel by Danilodiogo](https://www.kaggle.com/danilodiogo/google-play-store-eda-plotting-with-highcharts/code#eda).


