---
title: "Google Play Store Analytics"
subtitle: "ACS -Data analytics course project work"
author: "Group-3 : Sumadhuri Damerla, Shaoor Jan, Ashjan Khan"
output: 
  html_document:
    theme: cosmo
    highlight: monochrome
    toc: true
    toc_float: false
    toc_depth: 4
    css: styles.css
---

## **Summary**
The **google play store analytics** [dataset](https://www.kaggle.com/lava18/google-play-store-apps) offers insights into different apps, their ratings, user-reviews, installs and many other. In this report,we explore the dataset to find relations between columns...

## **1.Setup**
### 1.Loading necessary packages
```{r loading_libraries,message=FALSE, warning=FALSE}
```{r loading_libraries,message=FALSE, warning=FALSE}

library(tidyverse)
library(dplyr)
library(stringr)
library(wesanderson) # For colors
library(xts)
library(highcharter)
library(ggExtra) # For marginal graphs
theme_set(theme_light())


```


### 2. Creating a custom color pallet
Research has shown that specific concepts and phenomenon are associated with specific colors e.g money is most often associated with green color, oceans with blue and love with red. When colors are associated with the concepts that evoke them, this is called “semantically resonant color choices.” This concept is remarkably important for data visualization, and its effective communication. For this purpose, we created a custom color pallet, containing colors that are associated with the concepts of our dataset. This also help us be consistent with our choices of colors. 
Keeping in view accessibility, we have used colors that are color blind friendly. 
```{r echo=FALSE}
# reference: https://drsimonj.svbtle.com/creating-corporate-colour-palettes-for-ggplot2

custom_colors <- c(
  `red`             = "#d11141",
  `blueish green`   = "#009E73",
  `blue`            = "#0072B2",
  `sky blue`        = "#56B4E9",
  `orange`          = "#E69F00",
  `vermillion`      = "#D55E00",
  `yellow`          = "#009E73",
  `grey`            = "#999999",
  `reddish purple`  = "#CC79A7"
  )

custom_cols <- function(...) {
  cols <- c(...)
  
  if (is.null(cols))
    return (custom_colors)
  
  custom_colors[cols]
}

custom_palettes <- list(
  `main`  = custom_cols("blue", "green", "yellow"),
  
  `cool`  = custom_cols("blue", "green"),
  
  `hot`   = custom_cols("yellow", "orange", "red"),
  
  `mixed` = custom_cols("blue", "green", "yellow", "orange", "red"),
  
  `grey`  = custom_cols("light grey", "dark grey")
)

custom_pal <- function(palette = "main", reverse = FALSE, ...) {
  pal <- custom_palettes[[palette]]
  
  if (reverse) pal <- rev(pal)
  
  colorRampPalette(pal, ...)
}

scale_color <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)

  if (discrete) {
    discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_color_gradientn(colours = pal(256), ...)
  }
}

scale_fill <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)

  if (discrete) {
    discrete_scale("fill", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_fill_gradientn(colours = pal(256), ...)
  }
}

```



### 3.Loading Data
```{r loading_data,message = FALSE, warning = FALSE}


play_store <- read_csv("data/googleplaystore.csv")

user_review <- read_csv("data/googleplaystore_user_reviews.csv")

```
The loaded play store data contains `r play_store %>% count()` rows and the user review data contains `r user_review %>% count()` rows. 


## **2.Analysis**
### 1.Explore the data

+ Sneak peak at the data
```{r message=FALSE, warning=FALSE}
head(play_store)
```

+ View no. of rows
```{r message=FALSE, warning=FALSE}
dim(play_store)
```
The dataset contains `r dim(play_store) [1] ` rows and `r dim(play_store) [2] ` columns. By looking deeper into the dataset, it become clear that there are duplicate observations. The number of uniqe values in the column are `r length(unique(play_store$app)) `. Thus, we need to remove `r (dim(play_store) [1] - length(unique(play_store$app))) ` duplicate values.


+ View summary of data
```{r message=FALSE, warning=FALSE}
summary(play_store)
```
Summary shows that there are `r sum(is.na(play_store$rating))` missing values in rating column and `r sum(is.na(play_store$reviews))` missing value in reviews column. Rating can only be nan or null if the number of reviews are 0. Observations with nan rating and number of reviews greater than zero, does not represent corect data. As the number of these observations is less as compared to the whole dataset, we decided to remove them. 

+ View structure of data
```{r message=FALSE, warning=FALSE}
str(play_store)
```
As can be seen from the table, the data contains missing values, duplicates and many inconsistencies. --Add related text here

+ No. of apps in the dataset
```{r message=FALSE, warning=FALSE}
 length(unique(play_store$App))
```


### 2.Tidying Data
The column names in the dataset are not in accordance with the good practices and conventions of R, and were replaced with names that are in accordance with the naming conventions in R. 
```{r tidydata, message=FALSE, warning=FALSE}
# changing column names to remove spaces and other special characters and to maintain consistency
colnames(play_store) <- c("app", "category", "rating", "reviews", "size_mb", "installs", "types", "price", "content_rating", "genres", "last_update", "current_ver", "android_ver")

```

#### 1.Removing the duplicate values
```{r Removing duplicate values,message=FALSE, warning=FALSE}

#  Observations: Dataset include two different observations for the same app, with different reviews (number of reviews), we kept the lesser number, so not to create overly optimistic results
# another option is to take mean of the duplicate values and use it instead
arranged_data_set <- play_store %>% 
  arrange(app, desc(reviews))
dpl_value <- which(!duplicated(arranged_data_set$app))  
new_play_store <- arranged_data_set[dpl_value,]
clean_app_store <- arranged_data_set[dpl_value,]

```


#### 2.Missing data
+ Detecting missing data
Table included missing values.as shown below. 
```{r detect_missing_data,message=FALSE, warning=FALSE}
# Detect null cols and null rate
table(is.na(clean_app_store))
```
Missing rates are very low. We choose to delete them

+ Removing missing data
```{r remove_missing_data,message=FALSE, warning=FALSE}
colSums(is.na(clean_app_store))
```


#### 3.Cleaning the data 
Cleaning data includes the following:  
1. Removing data for wrong entered app:"Life Made WI-Fi Touchscreen Photo Frame"  
2. Removing observations with NaN rating which have reviews  
3. Modify datatype of "reviews" columns to numeric  
4. Convert all the app sizes to mb and modify it's datatype to numeric    
5. Remove unwanted characters in "installs" column and modify it's datatype to numeric  
6. Remove dollar sign in "price" column and modify it's datatype to numeric  
7. Seperate content rating column  
8. Modify the datatype of "last_update" column to date  
9. Modify the "android_version" column and modify it's datatype to numeric   
```{r clean_data,warning=FALSE,message=FALSE}
#### Removing wrong app-data ####
# Data for app "Life Made WI-Fi Touchscreen Photo Frame" removed (wrong rating, reviews, size e.t.c)
  clean_app_store <- clean_app_store[clean_app_store$app != "Life Made WI-Fi Touchscreen Photo Frame", ]

#### removing observations with reviews but NaN rating ####
 diff <- count(subset(new_play_store)) - count(subset(clean_app_store, !(is.na(clean_app_store$rating) & !clean_app_store$reviews == "0" )))

  clean_app_store <- subset(clean_app_store, !(is.na(clean_app_store$rating) & !clean_app_store$reviews == "0" ))

#### converting reviews to numeric ####
  clean_app_store$reviews <- as.numeric(clean_app_store$reviews)

#### Convert all app sizes to MB ####
  # changing all app sizes to MB
  selectedRows <- grep("k", clean_app_store$size_mb)
  clean_app_store$size_mb <- gsub('k', '', clean_app_store$size_mb)
  clean_app_store$size_mb <- gsub('M', '', clean_app_store$size_mb)
  clean_app_store$size_mb[selectedRows] <- as.numeric(clean_app_store$size_mb[selectedRows])  / 1024
  
  # convert into numeric 
  clean_app_store$size_mb <- as.numeric(clean_app_store$size_mb)

#### install column: remove "+", "," and convert into numeric ####
  # removing "+", ","
  clean_app_store$installs <- gsub('[[:punct:]]', '', clean_app_store$installs)
  
  # convert into numeric 
  clean_app_store$installs <- as.numeric(clean_app_store$installs)

####  price column: remove '$' and convert into numeric ####
  # removing "$"
  clean_app_store$price <- gsub( "\\$", '', clean_app_store$price)
  
  # convert into numeric 
  clean_app_store$price <- as.numeric(clean_app_store$price)
  
#### seperate content rating column ####
  clean_app_store$content_rating <- gsub( '\\+', '', clean_app_store$content_rating )
  
  clean_app_store <-  clean_app_store %>% 
    separate(content_rating, c("content_rating", "min_age"), convert = TRUE, sep = "\\s+(?=\\S*$)")

#### Convert last_update column into date ####
   clean_app_store$last_update <- as.Date(clean_app_store$last_update, format = "%d-%b-%y")
  

```







```{r }

#### current version column ####
  
# write.xlsx(clean_app_store, "mydata.xlsx")
#   
# # # convert into numeric 
# #   clean_app_store$current_ver <- as.numeric(clean_app_store$current_ver)
# #   
#   
#   ver_dev_rows <- grep("Varies with device", clean_app_store$android_ver)
#   clean_app_store_temp <- clean_app_store$android_ver[ver_dev_rows]
#   
#   # Fill with "Varies with device"
#   clean_app_store[ver_dev_rows, "min_android_ver"] <- clean_app_store_temp
#   #clean_app_store <-  clean_app_store %>% 
#    # separate(android_ver, c("min_android_ver", "max_android_ver"), sep = "\\s", )
#   
# 
# 
# #  write.xlsx(clean_app_store, "mydata.xlsx")
#   
#   
# #### android_ver column 
# 
# 
# ver_dev_rows <- grep("Varies with device", new_play_store$android_ver)
# 
# new_play_store_temp <- new_play_store$android_ver[ver_dev_rows]
# 
# 
# # Fill with "Varies with device"
# new_play_store[ver_dev_rows, "min_android_ver"] <- new_play_store_temp
# 
# 
# new_play_store <-  new_play_store %>%
#   separate(android_ver, c("min_android_ver", "max_android_ver"), sep = "\\s", )



```

## **3.Results : EDA**
### 1.Explore data after data cleaning and transformation
+ A look at the structure of data
```{r view_clean_data,message=FALSE, warning=FALSE}

str(clean_app_store)

``` 

+ A look at the summary of clean data
```{r}
summary(clean_app_store)
``` 
Rating ranges from 1 to 5 and the mean is pretty high. 

### 2.Pair plot

```{r pairplot,message=FALSE, warning=FALSE}
library(GGally)
clean_app_store$types <- as.factor(clean_app_store$types)

clean_app_store %>%
  select(rating, reviews, installs, price) %>%
  ggpairs(title = "correlogram with ggpairs()",
          mapping = ggplot2::aes(color = "types"))

```
We can observe that there is no significant linear relationship between rating and the plotted numerical variables.

```{r message=FALSE, warning=FALSE}
# Plot plot shows the relationship between different columms of data
# It will generate plot only for numreic value by default
#building a seaborn pairplot using pairplot()
#sns$pairplot(r_to_py(clean_app_store), hue = 'types')
#display the plot
#plt$show()
```


```{r python_pairplot,echo=FALSE,message=FALSE, warning=FALSE}
# Define variable containing url
url <- "/Users/jan_s/R Projects/GroupProject/PlayStoreAnalyticsRepo/pairplot.png"
# url <- "/Users/dsuma/Desktop/Courses/DataAnalytics-R/GroupProjectDirectory/PlayStoreAnalyticsRepo/PlayStoreAnalyticsRepo/pairplot.png" 
```
Pairplot!
![](`r url`)

### 3.Univariate plots
#### 1.Category
 Shows the number of apps in each category. We can see that family has the greatest percentage of apps. 
```{r category_plot,echo= FALSE,message=FALSE, warning=FALSE}

# Total number of categories
length(unique(clean_app_store$category))

# reorder(category, category, function(category) length(category))

# bar plot for category
clean_app_store %>%
  ggplot(aes(x = reorder(category, category, function(category) -length(category)) , fill = custom_cols("orange"))) +
  geom_bar(width = 0.5) +
#  coord_flip() +
  ggtitle("Number of Apps in each Categories") +
  labs(y="Count", x = "Category") +
  theme(legend.position = "None",
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90)
        )

# Number of apps in category
clean_app_store %>% 
  group_by(category)  %>% 
  summarise(count_of_apps = length(app)) %>% 
  arrange(-count_of_apps) %>% 
  mutate(perc_category = (count_of_apps / sum(count_of_apps) * 100 )) %>%
  ggplot(aes(x= reorder(category, -perc_category) , y = perc_category, fill = custom_cols("orange"))) +
  geom_bar(stat = "identity") +
  ggtitle("Number of Apps in each Categories") +
  labs(y="Count", x = "Category") +
  theme(legend.position = "None",
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90)
        )
  

```

We can observe that the family category has the most number of apps followed by game and tool categories.

#### 2.Price
```{r price_plot,echo= FALSE, message=FALSE, warning=FALSE}

clean_app_store %>%
  ggplot(aes(x = price)) +
  geom_histogram(fill = custom_cols("blueish green"), binwidth = 3) +
  scale_y_log10() +
  ggtitle('Distribution of Price') + 
  labs(y="Count", x = "Price") +
  theme(plot.title = element_text(hjust = 0.5))

```

Most of the apps are affordable and we can observe one outlier at 400 dollar range.

#### 3.Pie chart of type
```{r type_plot,message=FALSE, warning=FALSE}
clean_app_store %>%
  ggplot(aes(x=factor(1), fill=types)) +
  geom_bar(width = 1) +
  coord_polar("y") +
  ggtitle('Free and Paid App Distribution') +
  labs(y="", x = "") +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill(palette = "mixed") 
  

```

We can see that most of the apps are free.

#### 4.Reviews
```{r reviews_plot,echo= FALSE, message=FALSE, warning=FALSE}
# Histogram
clean_app_store %>%
  ggplot(aes(x = reviews))+
  geom_histogram(fill = custom_cols("red"))+
  scale_x_log10() +
  geom_vline(xintercept = median(clean_app_store$reviews), color = custom_cols("sky blue")) +
  ggtitle('Reviews') +
  labs(y="Count", x = "Review") +
   theme(plot.title = element_text(hjust = 0.5), 
         axis.text.x = element_text(vjust=0.5),
        legend.position = "None")





```

```{r}
#summary
summary(clean_app_store$reviews)
```
The number of reviews follows a left skewed distribution. About half the apps 
have more than 2747 reviews.(red line is the median)

#### 5.App rating
```{r rating_plot, message=FALSE, warning=FALSE}
#Histogram
clean_app_store %>%
  ggplot(aes(x = rating)) +
  geom_histogram(fill = custom_cols("vermillion")) +
  ggtitle('App Rating') +
  labs(y="Count", x = "Rating") +
   theme(plot.title = element_text(hjust = 0.5), 
         axis.text.x = element_text(vjust=0.5),
        legend.position = "None")


```

We can observe that there are very few apps with low ratings and most ratings are between 3-5


### 4.Bivariate & Multivariate plots
To look at which app makes it to the top, we can consider ratings, so we can explore correlation of different columns with ratings
#### 1.Plot of reviews vs app ratings
``` {r review_rating_plot,message = FALSE, warning = FALSE}
library(scales)

ggplot(data = clean_app_store) +
  geom_point(mapping = aes(x = rating, y = reviews, col = types)) +
  scale_color(discrete = TRUE, palette = "hot") +
  scale_y_continuous(trans='log10', labels=comma) +
  labs(title = "Android App Ratings vs Number of Reviews", subtitle = "Google Playstore Dataset", x = "Rating from 1 to 5 stars", y = "Number of Reviews") +
  theme_linedraw()

```


We can observe that the number of reviews influence the ratings. Generally, as the number of reviews increase, the rating is higher.


Let's explore other factors that potentially influence rating

#### 2.App rating vs category
```{r rating_category_plot,message=FALSE, warning=FALSE}

clean_app_store %>%
  ggplot(aes(x = reorder(category,rating), y = rating))+
  geom_boxplot(aes(fill = category)) +
  scale_fill(palette = "main") +
  #  coord_flip() +
  theme(legend.position = "None") + 
  ggtitle('Rating by category') + xlab("Category") + ylab("Rating")  +
   theme(axis.text.x = element_text(angle = 90))
 


```

#### 3.Top 10 installed apps
```{r top_apps_plot,message=FALSE, warning=FALSE}

clean_app_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls), y = totalInstalls, fill = custom_cols("red")) ) +
  geom_bar(fill = custom_cols("blueish green"), stat="identity") +
  ggtitle("Top 10 Installed Categories") +
  labs(y="Number of Installs", x = "Category") +
  scale_y_continuous(labels = comma) +
  theme(plot.title = element_text(hjust = 0.5), 
         axis.text.x = element_text(angle=90, vjust=0.5),
        legend.position = "None") 

   

clean_app_store%>%
  count(category, installs, types) %>%
  group_by(category, types) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls), y = totalInstalls, fill = types)) +
  geom_bar(stat="identity") +
  scale_fill(palette = "main") +
  theme(axis.text.x = element_text(angle = 90))
  labs(title= "Top 10 Installed Categories")

  
```



#### 4.Least 10 installed apps
```{r least_apps_plot,message=FALSE, warning=FALSE}
clean_app_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  tail(10) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = totalInstalls, fill = custom_cols("red"))) +
  geom_bar(fill = custom_cols("red"), stat="identity") +
  ggtitle("Least 10 Installed Categories") +
  labs(y="Number Of Installs", x = "Category") +
  scale_y_continuous(labels = comma) +
  theme(plot.title = element_text(hjust = 0.5), 
         axis.text.x = element_text(angle=90, vjust=0.5),
        legend.position = "None") 


clean_app_store%>%
  count(category, installs, types) %>%
  group_by(category, types) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  tail(10) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = totalInstalls, fill = types)) +
  geom_bar(stat="identity") +
  scale_fill(palette = "main") +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title= "Least 10 Installed Categories" )

```

#### 5. Top 10 paid apps
```{r plot,message=FALSE, warning=FALSE}

clean_app_store %>%
  filter(types == "Paid") %>%
  group_by(category) %>%
  summarize(totalInstalls = sum(installs)) %>%
  arrange(desc(totalInstalls)) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls) , y = totalInstalls)) +
  geom_bar( fill = custom_cols("blueish green"), stat="identity", width=.5) +
  ggtitle("Top 10 Paid Categories") +
  labs(y="Number Of Installs", x = "Category") +
   scale_y_continuous(labels = comma) +
  theme(plot.title = element_text(hjust = 0.5), 
         axis.text.x = element_text(angle=65, vjust=0.5),
        legend.position = "None") 



```



#### 7. Distribution of rating for 8 categories with the largest numbers of apps

```{r avg_rating_plot, message=FALSE, warning=FALSE}
# Distribution of rating for 8 categories with the largest numbers of apps
clean_app_store %>% 
 filter( category == c("FAMILY", "GAME", "TOOLS","MEDICAL", " BUSINESS", "PRODUCTIVITY", "FINANCE", "COMMUNICATION", "SPORTS")) %>% 
  ggplot(aes(x = rating)) +
  geom_bar(fill = custom_cols("blueish green"), na.rm = TRUE) + 
  facet_wrap(~category,  ncol = 4, nrow = 4,  shrink = TRUE) +
  ggtitle("Distribution of rating for 8 categories \n with the highest numbers of apps") +
  labs(y="Count", x = "Rating") +
  theme(
        plot.title = element_text(hjust = 0.5)
        )
```

#### 8. Average rating per category
```{r message=FALSE, warning=FALSE}
# Average rating per category
clean_app_store %>% 
  select(c("category", "rating")) %>% 
  group_by(category) %>% 
  summarise(rating = mean(rating, na.rm = TRUE)) %>% 
  ggplot(aes(x = reorder(category, - rating) , rating, fill = custom_cols("orange"))) + 
  geom_col() +
  ggtitle("Average Rating Per Category") +
  labs(y="Rating", x = "Category") +
  theme(axis.text.x = element_text(angle = 90),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5)
        ) 

```



#### 9. Size and rating 
We can see that apps with the their sizes under 30 MB, constitute the majority with a good rating(4)
```{r }


p <- clean_app_store %>% 
  ggplot(aes(x = size_mb, y = rating, na.rm =TRUE)) + 
  geom_point(color = custom_cols("blueish green"),na.rm =TRUE) +
  ggtitle("Size Vs Rating") +
  labs(y="Ratung", x = "Size (MB)") +
  theme(plot.title = element_text(hjust = 0.5))


 ggMarginal(p, type="histogram", fill = custom_cols("blueish green"), alpha = .6)

```


#### 10. Size and number of installs 
Apps with sizes between 5MB and 30MB gets the most number of installs. 
```{r }

p2 <- clean_app_store %>% 
  filter(!is.na(size_mb) ) %>% 
  ggplot(aes(x = size_mb, y = log(installs + 0.005), na.rm =TRUE)) + 
  geom_point(color = custom_cols("vermillion"), na.rm =TRUE) + 
  ggtitle("Size Vs Number of Installs ") +
  labs(y="No. of Installs (Log)", x = "Size (MB)") +
  theme(plot.title = element_text(hjust = 0.5))

  ggMarginal(p2, type="histogram", fill = custom_cols("vermillion"), alpha = .6)

```










