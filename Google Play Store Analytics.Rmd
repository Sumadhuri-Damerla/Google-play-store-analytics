---
title: "Google Play Store Analytics"
subtitle: "ACS -Data analytics course project work"
author: "Group-3 : Sumadhuri Damerla, Shaoor Jan, Ashjan Khan"
output: 
  html_document:
    theme: cosmo
    highlight: monochrome
    toc: true
    toc_float: false
    toc_depth: 4
    css: styles.css
---

## **Summary**
The **google play store analytics** [dataset](https://www.kaggle.com/lava18/google-play-store-apps) offers insights into different apps, their ratings, user-reviews, installs and many other. In this report,we explore the dataset to find relations between columns...

## **1.Setup**
### 1.Loading necessary packages
```{r loading_libraries,message=FALSE, warning=FALSE}

library(VIM)
library(mice)
library(tidyverse)
library(magrittr)
library(dplyr)
library(stringr)
library(xlsx)
library(wesanderson) # For colors
library(xts)
library(highcharter)
#library(xlsx)
#library(reticulate) #bridges python and R
theme_set(theme_minimal())

#use_python("/Users/dsuma/AppData/Local/Programs/Python/Python37", required = TRUE) #use path specific to your local machine and then remove this line.
#py_config() #to check which version of python is used
#importing required Python libraries/modules
#sns <- import('seaborn')
```


### 2. Creating a custom color pallet
Research has shown that specific concepts and phenomenon are associated with specific colors e.g money is most often associated with green color, oceans with blue and love with red. When colors are associated with the concepts that evoke them, this is called “semantically resonant color choices.” This concept is remarkably important for data visualization, and its effective communication. For this purpose, we created a custom color pallet, containing colors that are associated with the concepts of our dataset. This also help us be consistent with our choices of colors. 
Keeping in view accessibility, we have used colors that are color blind friendly. 
```{r }
custom_colors <- c(
  `red`             = "#d11141",
  `blueish green`   = "#009E73",
  `blue`            = "#0072B2",
  `sky blue`        = "#56B4E9",
  `orange`          = "#E69F00",
  `vermillion`      = "#D55E00",
  `yellow`          = "#009E73",
  `grey`            = "#999999",
  `reddidh purple`  = "#CC79A7"
  )

custom_cols <- function(...) {
  cols <- c(...)
  
  if (is.null(cols))
    return (custom_colors)
  
  custom_colors[cols]
}

custom_palettes <- list(
  `main`  = custom_cols("blue", "green", "yellow"),
  
  `cool`  = custom_cols("blue", "green"),
  
  `hot`   = custom_cols("yellow", "orange", "red"),
  
  `mixed` = custom_cols("blue", "green", "yellow", "orange", "red"),
  
  `grey`  = custom_cols("light grey", "dark grey")
)

custom_pal <- function(palette = "main", reverse = FALSE, ...) {
  pal <- custom_palettes[[palette]]
  
  if (reverse) pal <- rev(pal)
  
  colorRampPalette(pal, ...)
}

scale_color <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)

  if (discrete) {
    discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_color_gradientn(colours = pal(256), ...)
  }
}

scale_fill <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)

  if (discrete) {
    discrete_scale("fill", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_fill_gradientn(colours = pal(256), ...)
  }
}

# 
# ggplot(iris, aes(Sepal.Width, Sepal.Length, color = Sepal.Length)) +
#     geom_point(size = 4, alpha = .6) +
#     scale_color(discrete = FALSE, palette = "main")


# ggplot(mpg, aes(manufacturer, fill = manufacturer)) +
#     geom_bar() +
#     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#     scale_fill_drsimonj(palette = "mixed", guide = "none")



```



### 3.Loading Data
```{r loading_data,message = FALSE, warning = FALSE}


play_store <- read_csv("data/googleplaystore.csv")

user_review <- read_csv("data/googleplaystore_user_reviews.csv")

```
The loaded play store data contains `r play_store %>% count()` rows and the user review data contains `r user_review %>% count()` rows. 


## **2.Analysis**
### 1.Explore the data

+ Sneak peak at the data
```{r message=FALSE, warning=FALSE}
head(play_store)
```

+ View no. of rows
```{r message=FALSE, warning=FALSE}
dim(play_store)
```
The dataset contains `r dim(play_store) [1] ` rows and `r dim(play_store) [2] ` columns. By looking deeper into the dataset, it become clear that there are duplicate observations. The number of uniqe values in the column are `r length(unique(play_store$app)) `. Thus, we need to remove `r (dim(play_store) [1] - length(unique(play_store$app))) ` duplicate values.


+ View summary of data
```{r message=FALSE, warning=FALSE}
summary(play_store)
```
Summary shows that there are `r sum(is.na(play_store$rating))` missing values in rating column and `r sum(is.na(play_store$reviews))` missing value in reviews column. Rating can only be nan or null if the number of reviews are 0. Observations with nan rating and number of reviews greater than zero, does not represent corect data. As the number of these observations is less as compared to the whole dataset, we decided to remove them. 

+ View structure of data
```{r message=FALSE, warning=FALSE}
str(play_store)
```
As can be seen from the table, the data contains missing values, duplicates and many inconsistencies. --Add related text here

+ No. of apps in the dataset
```{r message=FALSE, warning=FALSE}
 length(unique(play_store$App))
```


### 2.Tidying Data
The column names in the dataset are not in accordance with the good practices and conventions of R, and were replaced with names that are in accordance with the naming conventions in R. 
```{r tidydata, message=FALSE, warning=FALSE}
# changing column names to remove spaces and other special characters and to maintain consistency
colnames(play_store) <- c("app", "category", "rating", "reviews", "size_mb", "installs", "types", "price", "content_rating", "genres", "last_update", "current_ver", "android_ver")

```

#### 1.Removing the duplicate values
```{r Removing duplicate values,message=FALSE, warning=FALSE}

#  Observations: Dataset include two different observations for the same app, with different reviews (number of reviews), we kept the lesser number, so not to create overly optimistic results
# another option is to take mean of the duplicate values and use it instead
arranged_data_set <- play_store %>% 
  arrange(app, desc(reviews))
dpl_value <- which(!duplicated(arranged_data_set$app))  
new_play_store <- arranged_data_set[dpl_value,]
clean_app_store <- arranged_data_set[dpl_value,]

```


#### 2.Missing data
+ Detecting missing data
Table included missing values.as shown below. 
```{r detect_missing_data,message=FALSE, warning=FALSE}
# Detect null cols and null rate
table(is.na(clean_app_store))
```
Missing rates are very low. We choose to delete them

+ Removing missing data
```{r remove_missing_data,message=FALSE, warning=FALSE}
colSums(is.na(clean_app_store))

# graph
# mis_data_pattern <- aggr(clean_app_store, col=c('navyblue','yellow'),
#  numbers=TRUE, sortVars=TRUE,
#  labels=names(clean_app_store), cex.axis=.7,
#  gap=3, ylab=c("Missing data","Pattern"))

```


#### 3.Cleaning the data 
Cleaning data includes the following:  
+ Removing data for wrong entered app:"Life Made WI-Fi Touchscreen Photo Frame"  
+ Removing observations with NaN rating which have reviews  
+ Modify datatype of "reviews" columns to numeric  
+ Convert all the app sizes to mb and modify it's datatype to numeric    
+ Remove unwanted characters in "installs" column and modufy it's datatype to numeric  
+ Remove dollar sign in "price" column and modify it's datatype to numeric  
+ Seperate content rating column  
+ Modify the datatype of "last_update" column to date  
+ Modify the "android_version" column and modify it's datatype to numeric  
 
```{r clean_data,warning=FALSE,message=FALSE}
#### Removing wrong app-data ####
# Data for app "Life Made WI-Fi Touchscreen Photo Frame" removed (wrong rating, reviews, size e.t.c)
  clean_app_store <- clean_app_store[clean_app_store$app != "Life Made WI-Fi Touchscreen Photo Frame", ]

#### removing observations with reviews but NaN rating ####
 diff <- count(subset(new_play_store)) - count(subset(clean_app_store, !(is.na(clean_app_store$rating) & !clean_app_store$reviews == "0" )))
diff

  clean_app_store <- subset(clean_app_store, !(is.na(clean_app_store$rating) & !clean_app_store$reviews == "0" ))

#### converting reviews to numeric ####
  clean_app_store$reviews <- as.numeric(clean_app_store$reviews)

#### Convert all app sizes to MB ####
  # changing all app sizes to MB
  selectedRows <- grep("k", clean_app_store$size_mb)
  clean_app_store$size_mb <- gsub('k', '', clean_app_store$size_mb)
  clean_app_store$size_mb <- gsub('M', '', clean_app_store$size_mb)
  clean_app_store$size_mb[selectedRows] <- as.numeric(clean_app_store$size_mb[selectedRows])  / 1024
  
  # convert into numeric 
  clean_app_store$size_mb <- as.numeric(clean_app_store$size_mb)

#### install column: remove "+", "," and convert into numeric ####
  # removing "+", ","
  clean_app_store$installs <- gsub('[[:punct:]]', '', clean_app_store$installs)
  
  # convert into numeric 
  clean_app_store$installs <- as.numeric(clean_app_store$installs)

####  price column: remove '$' and convert into numeric ####
  # removing "$"
  clean_app_store$price <- gsub( "\\$", '', clean_app_store$price)
  
  # convert into numeric 
  clean_app_store$price <- as.numeric(clean_app_store$price)
  
#### seperate content rating column ####
  clean_app_store$content_rating <- gsub( '\\+', '', clean_app_store$content_rating )
  
  clean_app_store <-  clean_app_store %>% 
    separate(content_rating, c("content_rating", "min_age"), convert = TRUE, sep = "\\s+(?=\\S*$)")

#### Convert last_update column into date ####
   clean_app_store$last_update <- as.Date(clean_app_store$last_update, format = "%d-%b-%y")
  

#### android version column ####
  ver_dev_rows <- grep("Varies with device", clean_app_store$android_ver)
  clean_app_store_temp <- clean_app_store$android_ver[ver_dev_rows]
  
  # Fill with "Varies with device"
  clean_app_store[ver_dev_rows, "min_android_ver"] <- clean_app_store_temp
  #clean_app_store <-  clean_app_store %>% 
   # separate(android_ver, c("min_android_ver", "max_android_ver"), sep = "\\s", )
  
  # convert into numeric 
  clean_app_store$current_ver <- as.numeric(clean_app_store$current_ver)

#  write.xlsx(clean_app_store, "mydata.xlsx")
  
  
#### android_ver column 


# ver_dev_rows <- grep("Varies with device", new_play_store$android_ver)
# 
# new_play_store_temp <- new_play_store$android_ver[ver_dev_rows]
# 
# 
# # Fill with "Varies with device"
# new_play_store[ver_dev_rows, "min_android_ver"] <- new_play_store_temp
# 
# 
# new_play_store <-  new_play_store %>% 
#   separate(android_ver, c("min_android_ver", "max_android_ver"), sep = "\\s", )
# 
# 
```


## **3.Results : EDA**

### 1.Explore data after data cleaning and transformation
+ A look at the structure of data
```{r view_clean_data,message=FALSE, warning=FALSE}

str(clean_app_store)

``` 

+ A look at the summary of clean data
```{r}
summary(clean_app_store)
``` 
Rating ranges from 1 to 5 and the mean is pretty high. 

### 2.Pair plot
```{r pairplot,message=FALSE, warning=FALSE}
library(GGally)
clean_app_store$types <- as.factor(clean_app_store$types)

clean_app_store %>%
  select(rating, reviews, installs, price) %>%
  ggpairs(title = "correlogram with ggpairs()",
          mapping = ggplot2::aes(color = "types"))

```


```{r message=FALSE, warning=FALSE}
# Plot plot shows the relationship between different columms of data
# It will generate plot only for numreic value by default
#building a seaborn pairplot using pairplot()
#sns$pairplot(r_to_py(clean_app_store), hue = 'types')
#display the plot
#plt$show()
```


```{r python_pairplot,echo=FALSE,message=FALSE, warning=FALSE}
# Define variable containing url
url <- "/Users/jan_s/R Projects/GroupProject/PlayStoreAnalyticsRepo/pairplot.png"
```
Pairplot!
![](`r url`)

### 3.Univariate plots
#### 1.Category
```{r category_plot,echo= FALSE,message=FALSE, warning=FALSE}
# bar plot for category
clean_app_store %>%
  ggplot(aes(x = category, fill = category)) +
  geom_bar(width = 0.5) +
  coord_flip() +
  ggtitle("Distribution of Categories") +
  theme(legend.position = "None") + 
  scale_fill(palette = "mixed", guide = "none")
  

```

We can observe that the family category has the most number of apps followed by game and tool categories.

#### 2.Price
```{r price_plot,echo= FALSE, message=FALSE, warning=FALSE}
clean_app_store %>%
  ggplot(aes(x = price))+
  geom_histogram(fill = 'red', binwidth = 3) +
  scale_y_log10() +
  ggtitle('Distribution of Price')
```

Most of the apps are affordable and we can observe one outlier at 400 dollar range.

#### 3.Pie chart of type
```{r type_plot,message=FALSE, warning=FALSE}
clean_app_store %>%
  ggplot(aes(x=factor(1), fill=types))+
  geom_bar(width = 1)+
  coord_polar("y")
```

We can see that most of the apps are free.

#### 4.Reviews
```{r reviews_plot,echo= FALSE, message=FALSE, warning=FALSE}

#Histogram
clean_app_store %>%
  ggplot(aes(x = reviews))+
  geom_histogram(fill = 'red')+
  scale_x_log10()+
  geom_vline(xintercept = median(clean_app_store$reviews), color = 'blue')+
  ggtitle('Reviews')
```

```{r}
#summary
summary(clean_app_store$reviews)
```
The number of reviews follows a left skewed distribution. About half the apps 
have more than 2747 reviews.(red line is the median)

#### 5.App rating
```{r rating_plot,echo= FALSE, message=FALSE, warning=FALSE}
#Histogram
clean_app_store %>%
  ggplot(aes(x = rating))+
  geom_histogram(fill = 'red')+
  scale_x_log10()+
  ggtitle('Rating')
```

We can observe that there are very few apps with low ratings and most ratings are between 3-5


### 4.Bivariate & Multivariate plots
To look at which app makes it to the top, we can consider ratings, so we can explore correlation of different columns with ratings
#### 1.Plot of reviews vs app ratings
``` {r review_rating_plot,message = FALSE, warning = FALSE}
library(scales)

ggplot(data = clean_app_store) +
  geom_point(mapping = aes(x = rating, y = reviews, col = types)) +
  scale_y_continuous(trans='log10', labels=comma) +
  labs(title = "Android App Ratings vs Number of Reviews", subtitle = "Google Playstore Dataset", x = "Rating from 1 to 5 stars", y = "Number of Reviews") +
  theme_linedraw()

```


We can observe that the no.of reviews influence the ratings. Generally, as the number of reviews increase, the rating is higher.


Let's explore other factors that potentially influence rating

#### 2.App rating vs category
```{r rating_category_plot,message=FALSE, warning=FALSE}

ggplot(clean_app_store, aes(x = rating,y = category,na.rm = TRUE)) + 
  geom_point(aes(color = 'red')) + 
  facet_wrap(.~types, drop = TRUE)

```

#### 3.Top 10 installed apps
```{r top_apps_plot,message=FALSE, warning=FALSE}

clean_app_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  head(10) %>%
  ggplot(aes(x = category, y = totalInstalls, fill = category)) +
  geom_bar(stat="identity") +
  labs(title= "Top10 Installed Categories" ) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```



#### 4.Least 10 installed apps
```{r least_apps_plot,message=FALSE, warning=FALSE}
clean_app_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  tail(10) %>%
  ggplot(aes(x = category, y = totalInstalls, fill = category)) +
  geom_bar(stat="identity") +
  labs(title= "Least 10 Installed Categories" ) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

#### 5. Top 10 paid apps
```{r plot,message=FALSE, warning=FALSE}

clean_app_store %>%
  filter(types == "Paid") %>%
  group_by(category) %>%
  summarize(totalInstalls = sum(installs)) %>%
  arrange(desc(totalInstalls)) %>%
  head(10) %>%
  ggplot(aes(x = category, y = totalInstalls, fill = 'red')) +
  geom_bar(stat="identity", width=.5) +
  labs(title= "Top 10 Paid Categories" ) +
  theme(axis.text.x = element_text(angle=65, vjust=0.5),legend.position = "None")

```


#### 6. Number of applications per category
 Shows the number of apps in each category. We can see that family has the greatest percentage of apps. 
```{r }

# Total number of categories
length(unique(clean_app_store$category))

# Number of apps in category
clean_app_store %>% 
  group_by(category)  %>% 
  summarise(count_of_apps = length(app)) %>% 
  arrange(-count_of_apps) %>% 
  mutate(perc_category = (count_of_apps / sum(count_of_apps) * 100 )) %>%
  ggplot(aes(x= reorder(category, -perc_category) , y = perc_category)) +
  geom_bar(stat = "identity") + 
  theme(axis.text.x = element_text(angle = 90))

```


#### 7. Average rating of apps
```{r avg_rating_plot, message=FALSE, warning=FALSE}


# Distribution of rating of all the categories
base <- ggplot(clean_app_store, aes(x = clean_app_store$rating))
base + 
  geom_bar(na.rm = TRUE) + 
  facet_wrap(~clean_app_store$category,  ncol = 4,  shrink = TRUE) +
  theme(
    strip.text.x = element_text(margin = margin(2, 2, 2, 2))
  )

# Distribution of rating for 8 categories with the highest numbers of apps
clean_app_store %>% 
 filter( category == c("FAMILY", "GAME", "TOOLS","MEDICAL", " BUSINESS", "PRODUCTIVITY", "FINANCE", "COMMUNICATION", "SPORTS")) %>% 
  ggplot(aes(x = rating)) +
  geom_bar(na.rm = TRUE) + 
  facet_wrap(~category,  ncol = 4, nrow = 4,  shrink = TRUE)


# Average rating per category
clean_app_store %>% 
  select(c("category", "rating")) %>% 
  group_by(category) %>% 
  summarise(rating = mean(rating, na.rm = TRUE)) %>% 
  ggplot(aes(category, rating)) + 
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill(palette = "mixed", guide = "none")

```



#### 8. Performance of apps based on category
```{r}






```












