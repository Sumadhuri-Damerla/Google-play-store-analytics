---
title: "Google Play Store Analytics"
subtitle: "ACS -Data analytics course project work"
author: "Group-3 : Sumadhuri Damerla, Shaoor Jan, Ashjan Khan"
output: 
   html_document: 
    theme: spacelab
    highlight: monochrome
    toc: true
    toc_float: false
    toc_depth: 4
    fig_caption: true
    df_print: paged
    css: styles.css
---

## **Introduction**
The **google play store analytics** [dataset](https://www.kaggle.com/lava18/google-play-store-apps) offers insights into different apps, their ratings, user-reviews, installs and many other. In this report,we explore the dataset to find relations between columns...

## **1.Setup**
### **1. Loading necessary packages**
```{r loading_libraries,message=FALSE, warning=FALSE}

library(tidyverse)
library(dplyr)
library(stringr)
require(ggExtra) # For marginal graphs
require(GGally) #for correlation plot
theme_set(theme_light())

```

### **2. Creating a custom color pallete**

Research has shown that specific concepts and phenomenon are associated with specific colors e.g money is most often associated with green color, oceans with blue and love with red. When colors are associated with the concepts that evoke them, this is called “semantically resonant color choices.” This concept is remarkably important for data visualization, and its effective communication. For this purpose, we created a custom color pallet, containing colors that are associated with the concepts of our dataset. This also help us be consistent with our choices of colors. 
Keeping in view accessibility, we have used colors that are color blind friendly. 
```{r }
# reference: https://drsimonj.svbtle.com/creating-corporate-colour-palettes-for-ggplot2

custom_colors <- c(
  `red`             = "#d11141",
  `blueish green`   = "#009E73",
  `blue`            = "#0072B2",
  `sky blue`        = "#56B4E9",
  `orange`          = "#E69F00",
  `vermillion`      = "#D55E00",
  `yellow`          = "#009E73",
  `grey`            = "#999999",
  `reddish purple`  = "#CC79A7"
)

custom_cols <- function(...) {
  cols <- c(...)
  
  if (is.null(cols))
    return (custom_colors)
  
  custom_colors[cols]
}

custom_palettes <- list(
  `main`  = custom_cols("blue", "green", "yellow"),
  
  `cool`  = custom_cols("blue", "green"),
  
  `hot`   = custom_cols("yellow", "orange", "red"),
  
  `mixed` = custom_cols("blue", "green", "yellow", "orange", "red"),
  
  `grey`  = custom_cols("light grey", "dark grey")
)

custom_pal <- function(palette = "main", reverse = FALSE, ...) {
  pal <- custom_palettes[[palette]]
  
  if (reverse) pal <- rev(pal)
  
  colorRampPalette(pal, ...)
}

scale_color <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)
  
  if (discrete) {
    discrete_scale("colour", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_color_gradientn(colours = pal(256), ...)
  }
}

scale_fill <- function(palette = "main", discrete = TRUE, reverse = FALSE, ...) {
  pal <- custom_pal(palette = palette, reverse = reverse)
  
  if (discrete) {
    discrete_scale("fill", paste0("drsimonj_", palette), palette = pal, ...)
  } else {
    scale_fill_gradientn(colours = pal(256), ...)
  }
}

```


### **3. Loading Data**
```{r loading_data,message = FALSE, warning = FALSE}

play_store <- read_csv("data/googleplaystore.csv")

```
The loaded play store data contains 10841 rows.

## **2.Analysis**
### **1.View the dataset** {.tabset .tabset-fade .tabset-pills}

#### Sneak peak at the data
```{r message=FALSE, warning=FALSE}

head(play_store)

```

#### No. of rows
```{r message=FALSE, warning=FALSE}

dim(play_store)

```
The dataset contains `r dim(play_store) [1] ` rows and `r dim(play_store) [2] ` columns. By looking deeper into the dataset, it become clear that there are duplicate observations. The number of unique values in the column are `r length(unique(play_store$app)) `. Thus, we need to remove `r (dim(play_store) [1] - length(unique(play_store$app))) ` duplicate values.


#### Summary of data
```{r message=FALSE, warning=FALSE}

summary(play_store)

```

1. Summary shows that there are `r sum(is.na(play_store$rating))` missing values in rating column and `r sum(is.na(play_store$reviews))` missing value in reviews column. 
2. Rating can only be NaN or null if the number of reviews are 0. Observations with NaN rating and number of reviews greater than zero does not represent correct data. As the number of these observations is less as compared to the whole dataset, we decided to remove them. 

#### Structure of data
```{r message=FALSE, warning=FALSE}

str(play_store)

```
As can be seen from the table, the data contains missing values, duplicates and many inconsistencies. --Add related text here

### **2.Exploring and Tidying Data**
As seen in above section, column names in the dataset are not in accordance with the good practices and conventions of R, and were replaced with names that are in accordance with the naming conventions in R. 
```{r tidydata, message=FALSE, warning=FALSE}

# changing column names to remove spaces and other special characters and to maintain consistency
colnames(play_store) <- c("app", "category", "rating", "reviews", "size_mb", "installs", "types", "price", "content_rating", "genres", "last_update", "current_ver", "android_ver")

```


#### **1.App column:**

```{r message=FALSE, warning=FALSE}

length(unique(play_store$app)) #number of unique apps in dataset

```

The number of rows in the dataset equals 10841 but the application names column has only 9660 unique values, ie there are applications with the same name. The following graph prompts us to ask the following questions:

 1.Why are there names of apps that are repeated more than once? 
 
 2.Is it the same application or different applications with the same name? After inspecting applications with the same names, it was found that these applications had almost the same characteristics, for the majority of them there was a difference in the number of reviews while others had differences in the number of reviews. the size, category and date of last update. This observation has pushed us to deepen our research to see if it is possible to have multiple applications with the same display name, actually this is possible provided you have different package names. It is later considered that these duplicate applications are due to a data collection error for two reasons:  
 
 3.Duplicate applications are recognized applications like Google Drive, Google Photos and Duolingo having a large number of installation (the same number) and the same evaluation rate. These application names are registered trademarks, so launching apps with these same names can lead to legal problems if there has been a decision to defend this trademark.  
 
 4.The dataset is published on Kaggle in 5 different versions, with a duration of one month between the first and the last version. It could therefore evolve during this period.  

##### Removing the duplicate values
```{r Removing duplicate values,message=FALSE, warning=FALSE}

#  Observations: Dataset include two different observations for the same app, with different reviews (number of reviews), we kept the lesser number, so not to create overly optimistic results
# another option is to take mean of the duplicate values and use it instead
arranged_data_set <- play_store %>% 
  arrange(app, desc(reviews))
dpl_value <- which(!duplicated(arranged_data_set$app))  
new_play_store <- arranged_data_set[dpl_value,]
clean_play_store <- arranged_data_set[dpl_value,]

```


#### **2.Category:**
```{r}

# Total number of categories
length(unique(play_store$category))

```

##### Category plot
```{r category_plot1,message=FALSE, warning=FALSE}

#Bar plot
 play_store %>%
    ggplot(aes(x = reorder(category, category, function(category) -length(category)) , fill = custom_cols("orange"))) +
    geom_bar(width = 0.5) +
    labs(title = "Bar plot",
         subtitle = "Number of Apps in each Categories",
         y = "Count",
         x = "Category",
         caption = "Source: google play store dataset") +
    theme(legend.position = "None",
          axis.text.x = element_text(angle = 90)
          )
```

+ We can observe that the family category has the most number of apps followed by game and tool categories.  
+ We have one observation having a category named 1.9 with a single application. Examining this application, we notice that it is an error due to a left shift.  


Removing data for wrong entered app:"Life Made WI-Fi Touchscreen Photo Frame" 
```{r clean_data,warning=FALSE,message=FALSE}

#### Removing wrong app-data ####
# Data for app "Life Made WI-Fi Touchscreen Photo Frame" removed (wrong rating, reviews, size e.t.c)
  clean_play_store <- clean_play_store[clean_play_store$app != "Life Made WI-Fi Touchscreen Photo Frame", ]

```

##### Percentage category plot after cleaning the column
```{r category_plot2,message=FALSE, warning=FALSE}

  clean_play_store %>% 
    group_by(category)  %>% 
    summarise(count_of_apps = length(app)) %>% 
    arrange(-count_of_apps) %>% 
    mutate(perc_category = (count_of_apps / sum(count_of_apps) * 100 )) %>%
    ggplot(aes(x = reorder(category, -perc_category) , y = perc_category, fill = custom_cols("orange"))) +
    geom_bar(width = 0.5, stat = "identity") +
    labs(title = "Bar plot",
         subtitle = "Percentage Apps in each Categories",
         y = "Count",
         x = "Category",
         caption = "Source: google play store dataset") +
    theme(legend.position = "None",
          axis.text.x = element_text(angle = 90)
          )

```

#### **3.Rating:**

Table included missing values as shown below  
```{r detect_missing_data,message=FALSE, warning=FALSE}

# Detect null cols and null rate
table(is.na(play_store))

colSums(is.na(play_store))

```
Missing rates are very low. We choose to delete them


Removing observations with NaN rating which have reviews  
```{r remove_missing_data,warning=FALSE,message=FALSE}

#### removing observations with reviews but NaN rating ####
 diff <- count(subset(new_play_store)) - count(subset(clean_play_store, !(is.na(clean_play_store$rating) & !clean_play_store$reviews == "0" )))

 clean_play_store <- subset(clean_play_store, !(is.na(clean_play_store$rating) & !clean_play_store$reviews == "0" ))

```


##### Rating plot
```{r rating_plot, message=FALSE, warning=FALSE}

#Density plot
clean_play_store %>%
  ggplot(aes(x = rating)) +
  geom_density(aes(fill = factor(types)), alpha = 0.5) +
  labs(title = "Density plot",
       subtitle = "App Rating grouped by types",
       y = "Density",
       x = "Rating",
       caption = "Source: google play store dataset",
       fill = "#Types") +
   theme(axis.text.x = element_text(vjust=0.5))

```

We can observe that there are very few apps with low ratings and most ratings are between 3-5

#### **4.Review :** 
We modify datatype of "reviews" column to numeric  
```{r warning=FALSE,message=FALSE}

#### converting reviews to numeric ####
  clean_play_store$reviews <- as.numeric(clean_play_store$reviews)

```  


##### Review distribution plot
```{r reviews_plot, message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = reviews))+
  geom_histogram(binwidth = 0.1,fill = custom_cols("reddish purple"))+
  scale_x_log10(labels = scales::comma) +
  geom_vline(xintercept = median(clean_play_store$reviews), color = custom_cols("sky blue")) +
  labs(title = "Histogram plot",
       subtitle = "Distribution of Reviews",
       y = "Count",
       x = "Review",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
        legend.position = "None") 
 
```

```{r}

#summary
summary(clean_play_store$reviews)

```

The number of reviews follows a left skewed distribution. About half the apps 
have more than 2747 reviews.(red line is the median)
 
#### **5.Size:**

Convert all the app sizes to mb and modify it's datatype to numeric 
```{r warning=FALSE,message=FALSE}

#### Convert all app sizes to MB ####
  # changing all app sizes to MB
  selectedRows <- grep("k", clean_play_store$size_mb)
  clean_play_store$size_mb <- gsub('k', '', clean_play_store$size_mb)
  clean_play_store$size_mb <- gsub('M', '', clean_play_store$size_mb)
  clean_play_store$size_mb[selectedRows] <- as.numeric(clean_play_store$size_mb[selectedRows])  / 1024
  
  # convert into numeric 
  clean_play_store$size_mb <- as.numeric(clean_play_store$size_mb)

```

```{r size_plot, message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = size_mb))+
  geom_density(binwidth = 0.1,fill = custom_cols("sky blue"))+
  labs(title = "Density plot",
       subtitle = "Size in MB",
       y = "Count",
       x = "Size (MB)",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
         legend.position = "None")

```

#### **6.Installs:**

Remove unwanted characters in "installs" column and modufy it's datatype to numeric  
```{r warning=FALSE,message=FALSE}

#### install column: remove "+", "," and convert into numeric ####
  # removing "+", ","
  clean_play_store$installs <- gsub('[[:punct:]]', '', clean_play_store$installs)
  
  # convert into numeric 
  clean_play_store$installs <- as.numeric(clean_play_store$installs)

```

```{r installs_plot, message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = size_mb))+
  geom_bar(binwidth = 0.5,fill = custom_cols("sky blue"))+
  labs(title = "Barplot",
       subtitle = "Distribution of installs",
       y = "Count",
       x = "Installs",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5),
         legend.position = "None")

```

#### **7.Price:**

We already know that paid apps only account for 7.46% of our dataset. Therefore, we will only look at the prices of paid applications. To do this, we will eliminate the dollar symbol and convert prices into numerical values.
```{r warning=FALSE,message=FALSE}

####  price column: remove '$' and convert into numeric ####
  # removing "$"
  clean_play_store$price <- gsub( "\\$", '', clean_play_store$price)
  
  # convert into numeric 
  clean_play_store$price <- as.numeric(clean_play_store$price)

```

##### Price plot
```{r price_plot, message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = price)) +
  geom_histogram(fill = custom_cols("blueish green"), binwidth = 5) +
  scale_y_log10() +
  labs(title = "Histogram plot",
       subtitle = "Distribution of price",
       y = "Count",
       x = "Price",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(vjust=0.5))

```

Most of the apps are affordable and we can observe one outlier at 400 dollar range.

#### **8.Content rating:**

Seperate content rating column  
```{r warning=FALSE,message=FALSE}

#### seperate content rating column ####
  clean_play_store$content_rating <- gsub( '\\+', '', clean_play_store$content_rating )
  
  clean_play_store <-  clean_play_store %>% 
    separate(content_rating, c("content_rating", "min_age"), convert = TRUE, sep = "\\s+(?=\\S*$)")

```

#### **9.Last update:**  

Modify the datatype of "last_update" column to date 
```{r warning=FALSE,message=FALSE}

#### Convert last_update column into date ####
   clean_play_store$last_update <- as.Date(clean_play_store$last_update, format = "%d-%b-%y")
  
```

#### **10.Types:**
```{r warning=FALSE,message=FALSE}

summary(play_store$types)

## There is one row with NaN value, let's check this row
play_store[play_store$types == 'NaN',]

```
As shown, price of this app is equal to 0 which means the App is Free
change the value of Type to Free

```{r warning=FALSE,message=FALSE}

#### Removing NAN in type column  
   clean_play_store$types <-  gsub(NaN, 'Free', clean_play_store$types) 

```

##### Pie plot of type
```{r type_plot,message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = factor(1), fill = types)) +
  geom_bar(width = 1, alpha = 0.7) +
  coord_polar(theta = "y", start = 0) +
  labs(title = "Pie chart",
       subtitle = "Free and Paid App Distribution",
       y = "App Count",
       x = "Factor(1)",
       caption = "Source: google play store dataset",
       fill = "Types") +
  theme(axis.ticks = element_blank(),
        panel.grid  = element_blank(),
        legend.title = element_text(hjust = 0.5, face = "bold", size = 10)) +
  scale_fill(palette = "main") 

```

We can see that most of the apps are free.

#### **11.Android version:**  

Splitting android_ver column into two columns: min_android_ver and max_android_ver. "up" in max_android_ver indicates the app is supported by latest versions of android.  
```{r warning=FALSE,message=FALSE}
#### current version column ####

# Indexes of strings with different patterns 
null_rows <- grep( NaN, clean_play_store$android_ver)
varies_with_dev_row <- grep("Varies with device", clean_play_store$android_ver)
with_dash <- grep("-", clean_play_store$android_ver)
and_up_obs <- grep("and", clean_play_store$android_ver)
  
# values with dash 
and_ver_with_dash_temp <- clean_play_store$android_ver[with_dash] 
and_ver_with_dash <-  sub(".*\\s", "", temp)

# Seperating COlumn min_android_ver
clean_play_store <-  clean_play_store %>% 
  separate(android_ver, c("min_android_ver", "max_android_ver"), convert = TRUE, sep = "\\s")
    
# Varies with deviece remived
clean_play_store$min_android_ver[varies_with_dev_row] <-  NA 
clean_play_store$max_android_ver[varies_with_dev_row] <-  NA 
 
# up in max_android_ver
clean_play_store$max_android_ver[and_up_obs] <-  "up"

# NaN in max_android_ver
clean_play_store$max_android_ver[null_rows] <-  NA
clean_play_store$min_android_ver[null_rows] <-  NA
 
# "-" values in max_android_ver   
clean_play_store$max_android_ver[with_dash] <- and_ver_with_dash

 
```

## **3.Further EDA**
### **1.Explore data after data cleaning and transformation** {.tabset .tabset-fade .tabset-pill}
#### A look at the structure of data
```{r view_clean_data,message=FALSE, warning=FALSE}

str(clean_play_store)

``` 

#### A look at the summary of clean data
```{r}

summary(clean_play_store)

``` 
Rating ranges from 1 to 5 and the mean is pretty high. 

### **2.Pair plot** {.tabset .tabset-fade .tabset-pills}

#### Rating vs Reviews
````{r pairplot1,message=FALSE, warning=FALSE}

clean_play_store$Reviews <- log(clean_play_store$reviews)

clean_play_store %>%
  select(rating, Reviews) %>%
  ggpairs(
          title = "Correlogram of Rating vs Reviews",
          mapping = ggplot2::aes(color = "types")) +
  theme(plot.title = element_text(hjust = 0.5))

```

#### Rating vs Installs
````{r pairplot2,message=FALSE, warning=FALSE}

clean_play_store$Installs <- log(clean_play_store$installs)

clean_play_store %>%
  select(rating, Installs) %>%
  ggpairs(
          title = "Correlogram of Rating vs Installs",
          mapping = ggplot2::aes(color = "types")) 

```

#### Rating vs Price
````{r pairplot3,message=FALSE, warning=FALSE}

clean_play_store$Price <- log(clean_play_store$price)

clean_play_store %>%
  select(rating, Price) %>%
  ggpairs(
          title = "Correlogram of Rating vs Price",
          mapping = ggplot2::aes(color = "types"))

```

#### Rating vs Types  
````{r pairplot4,message=FALSE, warning=FALSE}
clean_play_store$types <- as.factor(clean_play_store$types)

clean_play_store %>%
  select(rating, types) %>%
  ggpairs(
          title = "Correlogram of Rating vs Types",
          mapping = ggplot2::aes(color = "types"))

```


We can observe that there is no significant linear relationship between rating and the plotted numerical variables.

### **3.Bivariate & Multivariate plots**

To look at which app makes it to the top, we consider ratings, so we can explore correlation of different columns with ratings

#### **1.Plot of reviews vs app ratings**
``` {r review_rating_plot,message = FALSE, warning = FALSE}
ggplot(data = clean_play_store) +
  geom_point(mapping = aes(x = rating, y = reviews, col = types)) +
  scale_color(palette = "hot") +
  scale_y_continuous(trans = 'log10', labels = scales::comma) +
  labs(title = "Dot plot",
       subtitle = "Android App Ratings vs Number of Reviews",
       x = "Rating from 1 to 5 stars",
       y = "Number of Reviews",
       caption = "Source: google play store dataset",
       fill = "Types") +
 theme(legend.title = element_text(hjust = 0.5, face="bold", size = 10))

```


We can observe that the number of reviews influence the ratings. Generally, as the number of reviews increase, the rating is higher.


Let's explore other factors that might potentially influence rating

#### **2.App rating vs category**
```{r rating_category_plot,message=FALSE, warning=FALSE}

clean_play_store %>%
  ggplot(aes(x = reorder(category,rating), y = rating))+
  geom_boxplot(aes(fill = category)) +
  scale_fill(palette = "main") +
  labs(title = "Boxplot",
       subtitle = "Android App Ratings by category",
       x = "Category",
       y = "Rating",
       caption = "Source: google play store dataset") +
   theme(axis.text.x = element_text(angle = 90),
         legend.position = "None")
```

#### **3.Number of installs** {.tabset .tabset-fade .tabset-pill}

##### 3.1. Number of installs per category
```{r installs_plot1,message=FALSE, warning=FALSE}

clean_play_store%>%
  count(category, installs, types) %>%
  group_by(category, types) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = log(totalInstalls), fill = types)) +
  geom_bar(stat="identity") +
  scale_y_continuous(labels = scales::comma) +
  labs(title = "Barplot",
       subtitle = "Number of Installs per Category",
       x = "Category",
       y = "Number of Installs(log)",
       caption = "Source: google play store dataset") +
  scale_fill(palette = "main") +
  theme(axis.text.x = element_text(angle = 90)) 

```


##### 3.2.Top 10 installed categories  
```{r top_apps_plot,message=FALSE, warning=FALSE}

clean_play_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls), y = totalInstalls, fill = custom_cols("red"))) +
  geom_bar(width = 0.5, fill = custom_cols("blueish green"), stat = "identity") +
  labs(title = "Barplot",
       subtitle = "Top 10 Installed Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "None") 

```

##### 3.3.Ten least installed categories
```{r least_apps_plot,message=FALSE, warning=FALSE}


clean_play_store%>%
  count(category, installs) %>%
  group_by(category) %>%
  summarize(
    totalInstalls = sum(as.numeric(installs))
  ) %>%
  arrange(-totalInstalls) %>%
  tail(10) %>%
  ggplot(aes(x = reorder(category, totalInstalls), y = totalInstalls)) +
  geom_bar(width = 0.5, fill = custom_cols("vermillion"), stat = "identity") +
  labs(title = "Barplot",
       subtitle = "10 Least Installed Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position = "None") 
```


Since most of the apps are free, let's look at top 10 paid apps:  

#### **4. Top 10 paid apps** 
```{r plot,message=FALSE, warning=FALSE}

clean_play_store %>%
  filter(types == "Paid") %>%
  group_by(category) %>%
  summarize(totalInstalls = sum(installs)) %>%
  arrange(desc(totalInstalls)) %>%
  head(10) %>%
  ggplot(aes(x = reorder(category, -totalInstalls) , y = totalInstalls)) +
  geom_bar( fill = custom_cols("blueish green"), stat = "identity", width = 0.5) +
  labs(title = "Barplot",
       subtitle = "Top 10 Paid Categories",
       x = "Category",
       y = "Number of Installs",
       caption = "Source: google play store dataset") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 65, vjust = 0.5),
        legend.position = "None") 

```



#### **5. Distribution of rating for 8 categories with the largest numbers of apps** 

```{r avg_rating_plot, message=FALSE, warning=FALSE}

# Distribution of rating for 8 categories with the largest numbers of apps
clean_play_store %>% 
 filter( category == c("FAMILY", "GAME", "TOOLS","MEDICAL", " BUSINESS", "PRODUCTIVITY", "FINANCE", "COMMUNICATION", "SPORTS")) %>% 
  ggplot(aes(x = rating)) +
  geom_bar(fill = custom_cols("blueish green"), na.rm = TRUE) + 
  facet_wrap(~category,  ncol = 4, nrow = 4,  shrink = TRUE) +
  labs(title = "Facet plot",
       subtitle = "Distribution of rating for 8 categories with the highest numbers of apps",
       x = "Rating",
       y = "Count",
       caption = "Source: google play store dataset")

```

#### **6. Average rating per category** 
```{r avg_rating_category_plot,message=FALSE, warning=FALSE}

# Average rating per category
clean_play_store %>% 
  select(c("category", "rating")) %>% 
  group_by(category) %>% 
  summarise(rating = mean(rating, na.rm = TRUE)) %>% 
  ggplot(aes(x = reorder(category, - rating) , rating)) + 
  geom_col(width = 0.5, fill = custom_cols("sky blue")) +
  ggtitle("Average Rating Per Category") +
  labs(title = "Barplot",
       subtitle = "Average Rating Per Category",
       y = "Rating", 
       x = "Category",
      caption = "Source: google play store dataset") +
  theme(axis.text.x = element_text(angle = 90),
        legend.position = "none" ) 

```



#### **7. Size and rating**  
```{r size_rating_plot, message=FALSE, warning=FALSE}

plot <- clean_play_store %>% 
  ggplot(aes(x = size_mb, y = rating, na.rm = TRUE)) + 
  geom_point(color = custom_cols("blueish green"),na.rm = TRUE) +
  labs(title = "Marginalplot",
       subtitle = "Size Vs Rating",
       y = "Rating", 
       x = "Size (MB)",
      caption = "Source: google play store dataset") 

 ggMarginal(plot, type = "histogram", fill = custom_cols("blueish green"), alpha = 0.6)

```

We can see that apps with the their sizes under 30 MB, constitute the majority with a good rating(4)


#### **8. Size and number of installs**  
```{r size_installs_plot, message=FALSE, warning=FALSE}

plot <- clean_play_store %>% 
  filter(!is.na(size_mb) ) %>% 
  ggplot(aes(x = size_mb, y = log(installs + 0.005), na.rm = TRUE)) + 
  geom_point(color = custom_cols("vermillion"), na.rm = TRUE) + 
  labs(title = "Marginalplot",
       subtitle = "Size Vs Number of Installs",
       y = "No. of Installs (Log)", 
       x = "Size (MB)",
      caption = "Source: google play store dataset")
  ggMarginal(plot, type = "histogram", fill = custom_cols("vermillion"), alpha = 0.6)

```

Apps with sizes between 5MB and 30MB gets the most number of installs. 

## **References**

* [Dataset](https://www.kaggle.com/lava18/google-play-store-apps);
* [R markdown](https://bookdown.org/yihui/rmarkdown/html-document.html#tabbed-sections) ;
* [Stackoverflow](https://stackoverflow.com/questions/3993301/how-to-format-number-values-for-ggplot2-legend/15007117) ;
* [GGally](https://ggobi.github.io/ggally/rd.html#ggpairs);
* [Custom color pallete](https://drsimonj.svbtle.com/creating-corporate-colour-palettes-for-ggplot2);
* [Tidying data](https://medium.com/coinmonks/dealing-with-missing-data-using-r-3ae428da2d17);
* [Colors](https://hbr.org/2014/04/the-right-colors-make-data-easier-to-read);
* [TidyVerse](https://www.tidyverse.org/);
* [ggplot2](https://ggplot2.tidyverse.org/reference/);
* [Google playstore Kernel by Danilodiogo](https://www.kaggle.com/danilodiogo/google-play-store-eda-plotting-with-highcharts/code#eda).


